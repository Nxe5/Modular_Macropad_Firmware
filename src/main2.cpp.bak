#include "FS.h"
#include "SPIFFS.h"
#include "ArduinoJson.h"
#include "USB.h"
#include "USBCDC.h"  // Add CDC header
#include "tusb_config.h"

// Include your project modules
#include "ModuleSetup.h"
#include "EncoderHandler.h"
#include "LEDHandler.h"
#include "ConfigManager.h"
#include "KeyHandler.h"
#include "HIDHandler.h"
#include <tusb.h> 

// Create CDC Serial instance
USBCDC USBSerial;

//  Will be moved to info.json
#define ROW0 3  // Kept (safe GPIO pin)
#define ROW1 5  // Kept (safe GPIO pin)
#define ROW2 8  // ROW2 26
#define ROW3 9  // ROW3 47
#define ROW4 10 // ROW4 33
#define COL0 11 // COL0 34
#define COL1 21 // Kept (safe GPIO pin)
#define COL2 13 // Kept (safe GPIO pin)
#define COL3 6  // Kept (safe GPIO pin)
#define COL4 12 // Kept (safe GPIO pin)



// Define a more comprehensive USB descriptor
tusb_desc_device_t const desc_device = {
    .bLength            = sizeof(tusb_desc_device_t),
    .bDescriptorType    = TUSB_DESC_DEVICE,
    .bcdUSB             = 0x0200,  // USB 2.0
    .bDeviceClass       = 0x00,    // Defined by interface
    .bDeviceSubClass    = 0x00,
    .bDeviceProtocol    = 0x00,
    .bMaxPacketSize0    = CFG_TUD_ENDPOINT0_SIZE,
    .idVendor           = 0x1234,  // Replace with your actual Vendor ID
    .idProduct          = 0x5678,  // Replace with your actual Product ID
    .bcdDevice          = 0x0100,  // Device version 1.0
    .iManufacturer      = 0x01,
    .iProduct           = 0x02,
    .iSerialNumber      = 0x03,
    .bNumConfigurations = 0x01
};


// Global static variable to cache encoder actions (loaded once)
static std::map<String, ActionConfig> encoderActions;
static bool encoderActionsLoaded = false;

void directKeyboardScan() {
  uint8_t rowPins[5] = {ROW0, ROW1, ROW2, ROW3, ROW4};
  uint8_t colPins[5] = {COL0, COL1, COL2, COL3, COL4};
  
  // First set all pins to a known state
  for (int r = 0; r < 5; r++) {
    pinMode(rowPins[r], INPUT_PULLUP);
  }
  
  for (int c = 0; c < 5; c++) {
    pinMode(colPins[c], INPUT);  // High impedance when not scanning
  }
  
  // Scan one column at a time with verbose debugging
  for (int c = 0; c < 5; c++) {
    // Explicitly set this column as OUTPUT and drive it LOW
    pinMode(colPins[c], OUTPUT);
    digitalWrite(colPins[c], LOW);
    
    // Verify the pin is actually LOW
    Serial.printf("Setting column %d (pin %d) LOW. Voltage should be 0V\n", 
                  c, colPins[c]);
    
    // Longer delay to allow measurement
    delay(1000);
    
    // Check all rows
    for (int r = 0; r < 5; r++) {
      int rowValue = digitalRead(rowPins[r]);
      Serial.printf("Row %d (pin %d): %s\n", 
                    r, rowPins[r], rowValue == LOW ? "PRESSED" : "not pressed");
    }
    
    // Reset column to high impedance
    pinMode(colPins[c], INPUT);
    
    // Allow time between columns
    delay(500);
  }
}

// Command handling function for USB CDC console
void handleCDCCommand(const String &command) {
  if (command.startsWith("help")) {
    USBSerial.println("Available commands:");
    USBSerial.println("  help         - Show this help");
    USBSerial.println("  status       - Show device status");
    USBSerial.println("  led:on       - Turn all LEDs on (green)");
    USBSerial.println("  led:off      - Turn all LEDs off");
    USBSerial.println("  led:rgb R G B - Set all LEDs to RGB color (0-255)");
    USBSerial.println("  led:set N R G B - Set LED N to RGB color");
    USBSerial.println("  animation:start N - Start animation type N (0-3)");
    USBSerial.println("  animation:stop - Stop animation");
    USBSerial.println("  debug:keys   - Toggle key matrix debug");
    USBSerial.println("  debug:encoders - Toggle encoder debug");
  }
  else if (command.startsWith("status")) {
    USBSerial.println("NXE5 MacroPad Status:");
    USBSerial.printf("- USB Connected: %s\n", tud_mounted() ? "Yes" : "No");
    USBSerial.printf("- HID Ready: %s\n", tud_hid_ready() ? "Yes" : "No");
    USBSerial.printf("- CDC Connected: %s\n", tud_cdc_connected() ? "Yes" : "No");
    USBSerial.printf("- Key Matrix: %d buttons\n", currentModule.numButtons);
    USBSerial.printf("- LEDs: %d available\n", numLEDs);
    USBSerial.printf("- Encoders: %d configured\n", currentModule.numRotaryEncoders);
    USBSerial.printf("- Animation Active: %s\n", animationActive ? "Yes" : "No");
    USBSerial.printf("- Memory Free: %d bytes\n", ESP.getFreeHeap());
  }
  else if (command == "led:on") {
    setAllLEDs(0, 255, 0);  // Green
    USBSerial.println("All LEDs turned ON (green)");
  }
  else if (command == "led:off") {
    clearAllLEDs();
    USBSerial.println("All LEDs turned OFF");
  }
  else if (command.startsWith("led:rgb ")) {
    // Parse RGB values: led:rgb 255 0 128
    int r = 0, g = 0, b = 0;
    if (sscanf(command.c_str(), "led:rgb %d %d %d", &r, &g, &b) == 3) {
      // Constrain values to 0-255 range
      r = constrain(r, 0, 255);
      g = constrain(g, 0, 255);
      b = constrain(b, 0, 255);
      
      setAllLEDs(r, g, b);
      USBSerial.printf("All LEDs set to RGB(%d,%d,%d)\n", r, g, b);
    } else {
      USBSerial.println("Invalid RGB values. Format: led:rgb R G B");
    }
  }
  else if (command.startsWith("led:set ")) {
    // Parse LED index and RGB values: led:set 1 255 0 128
    int index = 0, r = 0, g = 0, b = 0;
    if (sscanf(command.c_str(), "led:set %d %d %d %d", &index, &r, &g, &b) == 4) {
      // Check index bounds
      if (index >= 0 && index < numLEDs) {
        // Constrain values to 0-255 range
        r = constrain(r, 0, 255);
        g = constrain(g, 0, 255);
        b = constrain(b, 0, 255);
        
        setLEDColor(index, r, g, b);
        USBSerial.printf("LED %d set to RGB(%d,%d,%d)\n", index, r, g, b);
      } else {
        USBSerial.printf("Invalid LED index. Must be between 0 and %d\n", numLEDs - 1);
      }
    } else {
      USBSerial.println("Invalid command format. Use: led:set INDEX R G B");
    }
  }
  else if (command.startsWith("animation:start ")) {
    // Parse animation type: animation:start 0
    int type = 0;
    if (sscanf(command.c_str(), "animation:start %d", &type) == 1) {
      if (type >= 0 && type <= 3) {
        startAnimation(type, 100);  // Start with default speed
        USBSerial.printf("Started animation type %d\n", type);
      } else {
        USBSerial.println("Invalid animation type. Must be between 0 and 3");
      }
    } else {
      USBSerial.println("Invalid command format. Use: animation:start TYPE");
    }
  }
  else if (command == "animation:stop") {
    stopAnimation();
    USBSerial.println("Animation stopped");
  }
  else if (command == "debug:keys") {
    static bool keyDebug = false;
    keyDebug = !keyDebug;
    
    if (keyDebug && keyHandler) {
      keyHandler->printKeyboardState();
      USBSerial.println("Key matrix debug ON");
    } else {
      USBSerial.println("Key matrix debug OFF");
    }
  }
  else if (command == "debug:encoders") {
    static bool encoderDebug = false;
    encoderDebug = !encoderDebug;
    
    if (encoderDebug && encoderHandler) {
      encoderHandler->printEncoderStates();
      USBSerial.println("Encoder debug ON");
    } else {
      USBSerial.println("Encoder debug OFF");
    }
  }
  else {
    USBSerial.printf("Unknown command: %s\n", command.c_str());
    USBSerial.println("Type 'help' for available commands");
  }
}

void testBasicGPIO() {
  // Clear all previous pin settings
  for(int i=0; i<22; i++) {
    pinMode(i, INPUT);
  }
  
  // Test a single GPIO pin that isn't part of your matrix
  const int testPin = 6; // Choose an unused GPIO pin
  
  pinMode(testPin, OUTPUT);
  
  // Toggle between HIGH and LOW every second
  while(true) {
    digitalWrite(testPin, LOW);
    Serial.println("Pin set to LOW - measure now");
    delay(2000);
    
    digitalWrite(testPin, HIGH);
    Serial.println("Pin set to HIGH - measure now");
    delay(2000);
  }
}

// Function to set all columns LOW for testing
void setAllColumnsLow() {
  uint8_t colPins[5] = {COL0, COL1, COL2, COL3, COL4};
  
  Serial.println("Setting all columns LOW for testing...");
  
  // Configure columns as OUTPUT
  for (int c = 0; c < 5; c++) {
    pinMode(colPins[c], OUTPUT);
    digitalWrite(colPins[c], LOW);  // Set LOW
    Serial.printf("Column %d (pin %d) set to LOW\n", c, colPins[c]);
  }
  
  Serial.println("All columns set to LOW. You can now measure each pin.");
}

// Function to list files in SPIFFS directory (for debugging)
void listDir(fs::FS &fs, const char* dirname, uint8_t levels) {
  Serial.printf("Listing directory: %s\n", dirname);
  File root = fs.open(dirname);
  if (!root) {
    Serial.println("Failed to open directory");
    return;
  }
  if (!root.isDirectory()) {
    Serial.println("Not a directory");
    return;
  }
  File file = root.openNextFile();
  while (file) {
    if (file.isDirectory()) {
      Serial.print("  DIR : ");
      Serial.println(file.name());
      if (levels) {
        listDir(fs, file.name(), levels - 1);
      }
    } else {
      Serial.print("  FILE: ");
      Serial.print(file.name());
      Serial.print("\tSIZE: ");
      Serial.println(file.size());
    }
    file = root.openNextFile();
  }
}

// Improved key mapping creation from components.json with no character overlaps
char** createKeyMappingFromComponents(const String& componentsJson, uint8_t rows, uint8_t cols) {
    // Allocate the key mapping grid
    char** keyMapping = new char*[rows];
    for (uint8_t i = 0; i < rows; i++) {
        keyMapping[i] = new char[cols];
        for (uint8_t j = 0; j < cols; j++) {
            keyMapping[i][j] = 'X';  // Initialize all positions as 'X'
        }
    }

    // Parse the components JSON
    DynamicJsonDocument doc(8192);
    DeserializationError error = deserializeJson(doc, componentsJson);
    
    if (error) {
        Serial.print("Error parsing components JSON: ");
        Serial.println(error.c_str());
        return keyMapping;
    }

    // Iterate through components
    JsonArray components = doc["components"].as<JsonArray>();
    
    for (JsonObject component : components) {
        String type = component["type"].as<String>();
        String id = component["id"].as<String>();
        
        // Check if component is a button or an encoder with a button
        if (type == "button" || 
            (type == "encoder" && 
             component.containsKey("with_button") && 
             component["with_button"].as<bool>())) {
            
            // Get the component's location
            uint8_t startRow = component["start_location"]["row"];
            uint8_t startCol = component["start_location"]["column"];
            
            // Extract the component number and create a unique key character
            char keyChar = 'X';
            
            if (type == "button") {
                // For buttons, extract number from id (e.g., "button-1" -> '1')
                int dashPos = id.indexOf('-');
                if (dashPos >= 0 && dashPos < id.length() - 1) {
                    String numStr = id.substring(dashPos + 1);
                    int buttonNum = numStr.toInt();
                    
                    if (buttonNum > 0 && buttonNum <= 9) {
                        // Buttons 1-9 -> '1'-'9'
                        keyChar = '0' + buttonNum;
                    } else if (buttonNum >= 10 && buttonNum <= 35) {
                        // Buttons 10-35 -> 'A'-'Z'
                        keyChar = 'A' + (buttonNum - 10);
                    }
                }
            } else if (type == "encoder" && component["with_button"].as<bool>()) {
                // For encoder buttons, use special characters that won't overlap with buttons
                // Use characters outside the normal ASCII range for better separation
                int dashPos = id.indexOf('-');
                if (dashPos >= 0 && dashPos < id.length() - 1) {
                    String numStr = id.substring(dashPos + 1);
                    int encoderNum = numStr.toInt();
                    // Use 'a'-'z' range for encoders to differentiate from buttons
                    keyChar = 'a' + (encoderNum - 1);  // encoder-1 -> 'a', encoder-2 -> 'b', etc.
                }
            }
            
            // Validate the location is within grid bounds
            if (startRow < rows && startCol < cols && keyChar != 'X') {
                // Assign the key marker based on component ID
                keyMapping[startRow][startCol] = keyChar;
                
                Serial.printf("Mapped %s at [%d,%d] with key %c\n", 
                              id.c_str(), startRow, startCol, keyChar);
            }
        }
    }

    // Debug print the entire key mapping
    Serial.println("Key mapping matrix:");
    for (uint8_t i = 0; i < rows; i++) {
        Serial.print("Row ");
        Serial.print(i);
        Serial.print(": ");
        for (uint8_t j = 0; j < cols; j++) {
            Serial.print(keyMapping[i][j]);
            Serial.print(" ");
        }
        Serial.println();
    }

    return keyMapping;
}

// Validate GPIO pins for ESP32-S3
bool validateGpioPins(uint8_t* pins, uint8_t count) {
    // Valid GPIO pins for ESP32-S3 are 0-21
    const int validESP32S3Pins[] = {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 
        15, 16, 17, 18, 19, 20, 21
    };
    
    for (uint8_t i = 0; i < count; i++) {
        bool isValid = false;
        for (int validPin : validESP32S3Pins) {
            if (pins[i] == validPin) {
                isValid = true;
                break;
            }
        }
        
        if (!isValid) {
            Serial.printf("Invalid GPIO pin for ESP32-S3: %d\n", pins[i]);
            return false;
        }
    }
    return true;
}

// Consistent pin configuration for key matrix
void configurePinModes(uint8_t* rowPins, uint8_t* colPins, uint8_t rows, uint8_t cols) {
    // Validate pins first with detailed ESP32-S3 validation
    if (!validateGpioPins(rowPins, rows) || !validateGpioPins(colPins, cols)) {
        Serial.println("Invalid GPIO pins detected for ESP32-S3!");
        return;
    }

    // IMPORTANT: For a matrix keyboard setup:
    // For a typical matrix keyboard setup:
    // - Configure rows as INPUT_PULLUP (will be read)
    // - Configure columns as OUTPUT (will be driven)
    
    // First, print the pin assignments for clarity
    Serial.println("\n--- Pin Configuration ---");
    Serial.println("Row pins (configured as INPUT_PULLUP):");
    for (uint8_t i = 0; i < rows; i++) {
        Serial.printf("  Row %d: GPIO %d\n", i, rowPins[i]);
    }
    
    Serial.println("Column pins (configured as OUTPUT):");
    for (uint8_t j = 0; j < cols; j++) {
        Serial.printf("  Column %d: GPIO %d\n", j, colPins[j]);
    }
    
    // Now configure the pins
    for (uint8_t i = 0; i < rows; i++) {
        pinMode(rowPins[i], INPUT_PULLUP);
    }

    for (uint8_t j = 0; j < cols; j++) {
        pinMode(colPins[j], OUTPUT);
        digitalWrite(colPins[j], HIGH);  // Start with HIGH (inactive)
    }
    
    Serial.println("Pin configuration complete\n");
}

// Function to debug actions configuration
void debugActionsConfig() {
    auto actions = ConfigManager::loadActions("/config/actions.json");
    
    Serial.println("\n=== Actions Configuration Debug ===");
    for (const auto& pair : actions) {
        Serial.printf("Button ID: %s, Type: %s\n", 
                    pair.first.c_str(), 
                    pair.second.type.c_str());
        
        if (pair.second.type == "multimedia" && !pair.second.consumerReport.empty()) {
            Serial.print("  Consumer Report: ");
            for (const auto& hex : pair.second.consumerReport) {
                Serial.printf("%s ", hex.c_str());
            }
            Serial.println();
        }
    }
    Serial.println("==================================\n");
}

// initializeKeyHandler() using a 5x5 grid and loading actions via ConfigManager
void initializeKeyHandler() {
  const uint8_t rows = 5;
  const uint8_t cols = 5;
  uint8_t rowPins[rows] = {ROW0, ROW1, ROW2, ROW3, ROW4};
  uint8_t colPins[cols] = {COL0, COL1, COL2, COL3, COL4};
  
  Serial.println("\n=== Initializing Keyboard Matrix ===");
  Serial.println("Matrix dimensions: 5x5");
  
  // Log pin assignments for clarity  
  Serial.println("Row pins:");
  for (int i = 0; i < rows; i++) {
    Serial.printf("  Row %d: GPIO %d\n", i, rowPins[i]);
  }
  
  Serial.println("Column pins:");
  for (int i = 0; i < cols; i++) {
    Serial.printf("  Column %d: GPIO %d\n", i, colPins[i]);
  }
  
  // Configure pin modes
  configurePinModes(rowPins, colPins, rows, cols);
  
  // Read components JSON from the file
  String componentsJson = ConfigManager::readFile("/config/components.json");
  Serial.println("Loading components from JSON...");
  
  // Create key mapping dynamically from components
  Serial.println("Creating key mapping from components...");
  char** keyMapping = createKeyMappingFromComponents(componentsJson, rows, cols);
  
  // Create and initialize the key handler instance
  Serial.println("Initializing key handler instance...");
  keyHandler = new KeyHandler(rows, cols, keyMapping, rowPins, colPins);
  
  if (keyHandler) {
    keyHandler->begin();
    
    // Load the actions configuration from SPIFFS
    Serial.println("Loading key action configuration...");
    auto actions = ConfigManager::loadActions("/config/actions.json");
    keyHandler->loadKeyConfiguration(actions);
    
    // Debug the loaded actions configuration
    debugActionsConfig();
    
    Serial.println("Key handler initialization complete");
  } else {
    Serial.println("ERROR: Failed to create key handler instance!");
  }
  
  // Clean up temporary keyMapping allocation
  for (uint8_t i = 0; i < rows; i++) {
    delete[] keyMapping[i];
  }
  delete[] keyMapping;
  
  Serial.println("=== Keyboard Matrix Initialization Complete ===\n");
}

void customKeyHandler() {
  static unsigned long lastScan = 0;
  const unsigned long scanInterval = 20; // ms
  
  // Only scan at regular intervals
  if (millis() - lastScan < scanInterval) {
    return;
  }
  lastScan = millis();
  
  uint8_t rowPins[5] = {ROW0, ROW1, ROW2, ROW3, ROW4};
  uint8_t colPins[5] = {COL0, COL1, COL2, COL3, COL4};
  
  // For tracking key state changes and debouncing
  static bool keyStates[5][5] = {0};
  static unsigned long lastDebounceTime[5][5] = {0};
  
  // IMPORTANT: Reverse the roles of rows and columns
  // This inverts the scanning direction to work better with diodes
  
  // Configure rows as OUTPUT initially (instead of columns)
  for (int r = 0; r < 5; r++) {
    pinMode(rowPins[r], OUTPUT);
    digitalWrite(rowPins[r], HIGH); // Start with HIGH (inactive)
  }
  
  // Configure columns as INPUT_PULLUP (instead of rows)
  for (int c = 0; c < 5; c++) {
    pinMode(colPins[c], INPUT_PULLUP);
  }
  
  // Scan one row at a time (reverse of normal scanning)
  for (int r = 0; r < 5; r++) {
    // Drive this row LOW
    digitalWrite(rowPins[r], LOW);
    
    delayMicroseconds(50); // Allow signal to stabilize
    
    // Check all columns
    for (int c = 0; c < 5; c++) {
      // Read the column pin
      bool currentReading = (digitalRead(colPins[c]) == LOW);
      
      // Debouncing
      if (currentReading != keyStates[r][c]) {
        lastDebounceTime[r][c] = millis();
      }
      
      if ((millis() - lastDebounceTime[r][c]) > DEBOUNCE_TIME) {
        if (currentReading != keyStates[r][c]) {
          keyStates[r][c] = currentReading;
          
          if (currentReading) {  // Key pressed
            // Map to button ID - this might need adjustment for your layout
            String buttonId = "button-" + String(r * 5 + c + 1);
            
            // Override for specific positions if needed
            if (r == 0 && c == 3) buttonId = "button-1";
            
            Serial.printf("Key press: Row %d, Col %d, ID=%s\n", r, c, buttonId.c_str());
            syncLEDsWithButtons(buttonId.c_str(), true);
          } else {  // Key released
            String buttonId = "button-" + String(r * 5 + c + 1);
            if (r == 0 && c == 3) buttonId = "button-1";
            
            Serial.printf("Key release: Row %d, Col %d, ID=%s\n", r, c, buttonId.c_str());
            syncLEDsWithButtons(buttonId.c_str(), false);
          }
        }
      }
    }
    
    // Set row back to inactive
    digitalWrite(rowPins[r], HIGH);
  }
}

void safeButtonTest() {
  // Only test one specific button to avoid hardware conflicts
  // Button-1 at row 0, column 3
  uint8_t rowPin = ROW0;  // 3
  uint8_t colPin = COL4;  // 12
  
  // Configure pins carefully
  pinMode(rowPin, INPUT_PULLUP);
  pinMode(colPin, OUTPUT);
  digitalWrite(colPin, LOW);
  
  // Read state
  int reading = digitalRead(rowPin);
  
  // Show result
  Serial.printf("Button test (standard): %s\n", 
               reading == LOW ? "PRESSED" : "NOT PRESSED");
  
  // Reset pins to safe state
  pinMode(rowPin, INPUT);
  pinMode(colPin, INPUT);
  
  // Try reversed configuration
  delay(100);
  pinMode(colPin, INPUT_PULLUP);
  pinMode(rowPin, OUTPUT);
  digitalWrite(rowPin, LOW);
  
  // Read state
  reading = digitalRead(colPin);
  
  // Show result
  Serial.printf("Button test (reversed): %s\n", 
               reading == LOW ? "PRESSED" : "NOT PRESSED");
  
  // Reset pins to safe state
  pinMode(rowPin, INPUT);
  pinMode(colPin, INPUT);
  
  delay(1000);
}

// Modified initializeEncoderHandler remains as before

void initializeEncoderHandler() {
    // Read components JSON from the file
    String componentsJson = ConfigManager::readFile("/config/components.json");
    Serial.println("Loading components from JSON for encoders...");
    
    // Parse the components to get encoder configurations
    std::vector<Component> components = ConfigManager::loadComponents("/config/components.json");
    
    // Count encoders
    uint8_t encoderCount = 0;
    for (const Component& comp : components) {
        if (comp.type == "encoder") {
            encoderCount++;
        }
    }
    
    Serial.printf("Found %d encoders in configuration\n", encoderCount);
    
    // Create handler if we have encoders
    if (encoderCount > 0) {
        encoderHandler = new EncoderHandler(encoderCount);
        
        // Configure each encoder
        uint8_t encoderIndex = 0;
        for (const Component& comp : components) {
            if (comp.type == "encoder") {
                // Use a larger capacity for JSON parsing here
                DynamicJsonDocument doc(8192);
                DeserializationError error = deserializeJson(doc, componentsJson);
                if (error) {
                    Serial.printf("Error parsing components JSON: %s\n", error.c_str());
                    continue;
                }
                
                // Find this encoder in the parsed JSON
                JsonArray jsonComponents = doc["components"].as<JsonArray>();
                JsonObject encoderConfig;
                for (JsonObject component : jsonComponents) {
                    if (component["id"].as<String>() == comp.id) {
                        encoderConfig = component;
                        break;
                    }
                }
                
                if (!encoderConfig.isNull()) {
                    // Determine encoder type (default mechanical unless configured as as5600)
                    EncoderType type = ENCODER_TYPE_MECHANICAL;
                    if (encoderConfig.containsKey("configuration") && 
                        encoderConfig["configuration"].containsKey("type") &&
                        encoderConfig["configuration"]["type"].as<String>() == "as5600") {
                        type = ENCODER_TYPE_AS5600;
                    }
                    
                    // Get pins and configuration
                    uint8_t pinA = 0, pinB = 0;
                    int8_t direction = 1;
                    
                    if (encoderConfig.containsKey("mechanical")) {
                        pinA = encoderConfig["mechanical"]["pin_a"] | 0;
                        pinB = encoderConfig["mechanical"]["pin_b"] | 0;
                    }
                    
                    if (encoderConfig.containsKey("configuration") && 
                        encoderConfig["configuration"].containsKey("direction")) {
                        direction = encoderConfig["configuration"]["direction"] | 1;
                    }
                    
                    // Configure this encoder
                    Serial.printf("Configuring %s: type=%d, pinA=%d, pinB=%d, direction=%d\n", 
                                  comp.id.c_str(), type, pinA, pinB, direction);
                    
                    encoderHandler->configureEncoder(
                        encoderIndex++,
                        type,
                        pinA,
                        pinB,
                        direction,
                        0 // zeroPosition
                    );
                }
            }
        }
        
        // Initialize the configured encoders
        encoderHandler->begin();
        Serial.println("Encoder handler initialized successfully");
    } else {
        Serial.println("No encoders found in configuration");
    }
}

bool testI2CPins(uint8_t sdaPin, uint8_t sclPin) {
    // End any previous I2C communication
    Wire.end();
    
    // Try to initialize I2C on the specified pins
    Wire.begin(sdaPin, sclPin);
    
    // Attempt an I2C scan (this won't find anything but tests if pins can be configured)
    Wire.beginTransmission(0x36); // AS5600 address
    uint8_t error = Wire.endTransmission();
    
    // We expect error 2 (received NACK on transmit of address) if no device is present
    // but pins can be used for I2C. Any other error might indicate pin configuration problems.
    Serial.printf("Testing I2C pins SDA=%d, SCL=%d: ", sdaPin, sclPin);
    if (error == 2) {
        Serial.println("Pins can be used for I2C (no device found, as expected)");
        return true;
    } else if (error == 0) {
        Serial.println("Unexpectedly received ACK - is a device connected?");
        return true; // Pins are working
    } else {
        Serial.printf("Error %d - pins might not be usable for I2C\n", error);
        return false;
    }
}

// Ensure USB pins are clear for USB operation
void prepareUsbPins() {
    // ESP32-S3 USB pins
    pinMode(19, INPUT);  // USB D-
    pinMode(20, INPUT);  // USB D+
    
    // Clear any interference
    digitalWrite(19, LOW);
    digitalWrite(20, LOW);
}

void processEncoderDelta(long delta, const String& encoderId) {
    if (!encoderActionsLoaded) {
        encoderActions = ConfigManager::loadActions("/config/actions.json");
        encoderActionsLoaded = true;
    }

    auto actionIt = encoderActions.find(encoderId);
    if (actionIt == encoderActions.end()) {
        Serial.printf("No action found for encoder: %s\n", encoderId.c_str());
        return;
    }

    ActionConfig encAction = actionIt->second;
    uint8_t report[8] = {0};
    bool wasReportSent = false;

    std::vector<String> reportHex;
    Serial.printf("Encoder delta: %ld\n", delta);

    if (delta < 0 && !encAction.clockwise.empty()) {
        Serial.println("Encoder turned CLOCKWISE");
        reportHex = encAction.clockwise;
    } else if (delta > 0 && !encAction.counterclockwise.empty()) {
        Serial.println("Encoder turned COUNTERCLOCKWISE");
        reportHex = encAction.counterclockwise;
    } else {
        return;  // No suitable action found
    }

    if (HIDHandler::hexReportToBinary(reportHex, report, 8) && hidHandler) {
        wasReportSent = hidHandler->sendKeyboardReport(report);
        Serial.printf("Report Sent: %s\n", wasReportSent ? "YES" : "NO");
    }
}

// Define a global USB configuration status
bool usbConfigured = false;


void setupUSB() {
    Serial.println("\n=== Detailed USB Initialization ===");
    
    // Maximum initialization attempts
    const int MAX_INIT_ATTEMPTS = 5;
    bool usbInitSuccess = false;
    
    for (int attempt = 1; attempt <= MAX_INIT_ATTEMPTS; attempt++) {
        Serial.printf("USB Initialization Attempt %d/%d\n", attempt, MAX_INIT_ATTEMPTS);
        
        // Attempt to begin USB
        bool initResult = USB.begin();
        
        // Debug information about USB initialization
        Serial.printf("USB.begin() Result: %s\n", initResult ? "SUCCESS" : "FAILED");
        
        // Intensive USB task processing
        Serial.println("Processing USB tasks...");
        for (int i = 0; i < 100; i++) {
            tud_task();
            delayMicroseconds(100);
        }
        
        // Comprehensive USB status checks
        bool mountedStatus = tud_mounted();
        bool hidReadyStatus = tud_hid_ready();
        // bool cdcConnectedStatus = tud_cdc_connected();
        
        Serial.printf("USB Mounted: %s\n", mountedStatus ? "YES" : "NO");
        Serial.printf("HID Ready: %s\n", hidReadyStatus ? "YES" : "NO");
        // Serial.printf("CDC Connected: %s\n", cdcConnectedStatus ? "YES" : "NO");
        
        // Determine if configuration was successful
        if (mountedStatus && hidReadyStatus) {
            usbInitSuccess = true;
            Serial.println("USB Configuration Successful!");
            break;
        }
        
        // Delay between attempts
        delay(500);
    }
    
    // Final check for USB configuration
    usbConfigured = usbInitSuccess;  // Set the global flag
    
    if (!usbInitSuccess) {
        Serial.println("!!!CRITICAL: USB INITIALIZATION FAILED!!!");
        // Optional: Add a way to signal critical failure
        // For example, you could set a global flag or trigger an error LED
    }
}

void resetAllPins() {
    // Save USB pins state
    int usbPinModes[2];
    pinMode(19, INPUT); // USB D-
    pinMode(20, INPUT); // USB D+
    
    // Reset all other GPIO pins to a safe state
    for(int i=0; i<22; i++) {
        if(i != 19 && i != 20) { // Skip USB pins
            pinMode(i, INPUT);
            digitalWrite(i, LOW);
        }
    }
    
    Serial.println("All GPIO pins reset to safe INPUT state");
}

void logUSBDescriptors() {
  // Log Device Descriptor
  const uint8_t* devDesc = tud_descriptor_device_cb();
  Serial.println("=== Device Descriptor ===");
  for (size_t i = 0; i < sizeof(tusb_desc_device_t); i++) {
    Serial.printf("%02X ", devDesc[i]);
    if ((i + 1) % 16 == 0) Serial.println();
  }
  Serial.println("\n");

  // Log Configuration Descriptor
  const uint8_t* configDesc = tud_descriptor_configuration_cb(0);
  // The total length is stored in bytes 2 and 3 of the configuration descriptor.
  uint16_t totalLength = configDesc[2] | (configDesc[3] << 8);
  Serial.printf("=== Configuration Descriptor (Total Length: %d) ===\n", totalLength);
  for (uint16_t i = 0; i < totalLength; i++) {
    Serial.printf("%02X ", configDesc[i]);
    if ((i + 1) % 16 == 0) Serial.println();
  }
  Serial.println("\n");

  // Log String Descriptors (using index 0 through 4 as defined)
  Serial.println("=== String Descriptors ===");
  // There are 5 string descriptors in your array (indexes 0 to 4)
  for (uint8_t i = 0; i < 5; i++) {
    uint16_t const* strDesc = tud_descriptor_string_cb(i, 0x0409);
    if (strDesc) {
      // The first word contains the length (in bytes) and descriptor type.
      uint8_t len = strDesc[0] & 0xFF;
      Serial.printf("String %d: ", i);
      // Each character is 16-bit, so loop over (len/2 - 1) characters.
      for (uint8_t j = 1; j < len / 2; j++) {
        Serial.print((char)strDesc[j]);
      }
      Serial.println();
    }
  }
}

void setup() {
  // Initialize serial communication
  Serial.begin(115200);
  delay(3000); // Allow time for serial monitor to connect
  
  // Print boot message
  Serial.println("\n=== NXE5 Modular MacroPad Initializing ===");
  
  // Initialize filesystem
  if (!SPIFFS.begin(true)) {
    Serial.println("ERROR: SPIFFS initialization failed!");
    while (1) {
      // Blink LED rapidly to indicate error
      digitalWrite(LED_BUILTIN, HIGH);
      delay(100);
      digitalWrite(LED_BUILTIN, LOW);
      delay(100);
    }
  }
  Serial.println("SPIFFS initialized successfully");
  
  // List files in SPIFFS (for debugging)
  listDir(SPIFFS, "/config", 1);
  
  // Initialize module information
  initializeModuleInfo();

  // Initialize USB with both CDC and HID functionality
  Serial.println("Initializing USB with CDC and HID...");
  USB.begin();
  
  // Initialize USB CDC Serial for communication
  Serial.println("Starting USB CDC Serial...");
  USBSerial.begin();
  
  // Wait for USB to initialize properly
  int usbWaitCount = 0;
  while (!tud_mounted() && usbWaitCount < 10) {
    Serial.println("Waiting for USB to initialize...");
    tud_task();
    delay(500);
    usbWaitCount++;
  }
  
  // Initialize hardware components
  initializeKeyHandler();
  initializeHIDHandler();
  initializeEncoderHandler();
  initializeLED();
  
  // Debug actions configuration
  debugActionsConfig();
  
  // Perform some diagnostics
  if (keyHandler) {
    keyHandler->diagnostics();
  }
  
  if (encoderHandler) {
    encoderHandler->diagnostics();
  }
  
  // Set initial LED colors
  if (strip) {
    // Make a startup animation: all LEDs light up in sequence
    for (int i = 0; i < numLEDs; i++) {
      setLEDColor(i, 0, 255, 0);  // Green
      delay(50);
    }
    delay(500);
    
    // Then set them to their configured colors
    for (int i = 0; i < numLEDs; i++) {
      float factor = ledConfigs[i].brightness / 255.0;
      strip->setPixelColor(i, strip->Color(
        ledConfigs[i].r * factor,
        ledConfigs[i].g * factor,
        ledConfigs[i].b * factor
      ));
    }
    strip->show();
  }
  
  // Print initialization complete message
  Serial.println("\n=== Initialization Complete ===");
  Serial.println("Module ID: " + currentModule.uniqueId);
  Serial.println("Module Type: " + String(getModuleTypeName(currentModule.type)));
  Serial.println("Buttons: " + String(currentModule.numButtons));
  Serial.println("LEDs: " + String(currentModule.numLEDs));
  Serial.println("Encoders: " + String(currentModule.numRotaryEncoders));
  
  // Send initial message and help via USB Serial
  USBSerial.println("\n=== NXE5 MacroPad USB CDC + HID ===");
  USBSerial.println("Firmware version 1.0");
  USBSerial.println("USB Composite Device Ready!");
  USBSerial.println("Type 'help' for available commands");
  USBSerial.print("> ");
}

void loop() {
  // Process USB tasks
  tud_task();
  
  // Handle USB CDC Serial if available
  if (USBSerial && USBSerial.available()) {
    String command = USBSerial.readStringUntil('\n');
    command.trim();
    
    // Process commands received via USB Serial
    if (command.length() > 0) {
      USBSerial.printf("> %s\n", command.c_str());
      handleCDCCommand(command);
    }
  }
  
  // Update hardware handlers
  if (keyHandler) {
    keyHandler->updateKeys();
  }
  
  if (hidHandler) {
    hidHandler->update();
  }
  
  if (encoderHandler) {
    // Update encoder values
    encoderHandler->updateEncoders();
    
    // Process encoder movements
    static long lastEncoderPositions[MAX_ENCODERS] = {0};
    
    // Check each encoder for changes
    for (uint8_t i = 0; i < MAX_ENCODERS; i++) {
      if (encoderHandler->getEncoderType(i) != ENCODER_TYPE_MECHANICAL &&
          encoderHandler->getEncoderType(i) != ENCODER_TYPE_AS5600) {
        continue;  // Skip invalid encoders
      }
      
      long currentPosition = encoderHandler->getEncoderPosition(i);
      long delta = currentPosition - lastEncoderPositions[i];
      
      if (delta != 0) {
        // Generate encoder ID based on index
        String encoderId = "encoder-" + String(i + 1);
        
        // Process the encoder movement
        processEncoderDelta(delta, encoderId);
        
        // Report to USB CDC if connected
        if (tud_cdc_connected()) {
          USBSerial.printf("Encoder %d moved: %ld\n", i + 1, delta);
        }
        
        // Update last position
        lastEncoderPositions[i] = currentPosition;
      }
    }
  }
  
  // Update LED animations if active
  if (animationActive) {
    updateAnimation();
  }
  
  // Perform periodic diagnostics
  static unsigned long lastDiagnosticTime = 0;
  const unsigned long diagnosticInterval = 30000;  // 30 seconds
  
  if (millis() - lastDiagnosticTime >= diagnosticInterval) {
    lastDiagnosticTime = millis();
    
    Serial.println("\n=== Periodic System Diagnostics ===");
    
    // USB status
    Serial.print("USB Status: ");
    Serial.println(tud_mounted() ? "Connected" : "Disconnected");
    
    // Output to USB Serial as well
    if (tud_cdc_connected()) {
      USBSerial.println("\n=== Periodic System Diagnostics ===");
      USBSerial.printf("USB Status: %s\n", tud_mounted() ? "Connected" : "Disconnected");
      USBSerial.printf("Free Memory: %d bytes\n", ESP.getFreeHeap());
      USBSerial.printf("Uptime: %lu seconds\n", millis() / 1000);
    }
    
    // Key handler status
    if (keyHandler) {
      keyHandler->diagnostics();
    }
    
    // Encoder handler status
    if (encoderHandler) {
      encoderHandler->diagnostics();
    }
    
    Serial.println("=== Diagnostics Complete ===\n");
  }
  
  // Small delay to prevent CPU overload
  delay(1);
}